# 005运行机制与核心工作原理

Webpack 在整个打包的过程中：
- 通过 Loader 处理特殊类型资源的加载，例如加载样式、图片；
- 通过 Plugin 实现各种自动化的构建任务，例如自动压缩、自动发布。

打包的过程:
Webpack 启动后，会根据我们的配置，找到项目中的某个指定文件（一般这个文件都会是一个 JS 文件）作为入口。然后顺着入口文件中的代码，根据代码中出现的 import（ES Modules）或者是 require（CommonJS）之类的语句，解析推断出来这个文件所依赖的资源模块，然后再分别去解析每个资源模块的依赖，周而复始，最后形成整个项目中所有用到的文件之间的依赖关系树

有了这个依赖关系树过后， Webpack 会遍历（递归）这个依赖树，找到每个节点对应的资源文件，然后根据配置选项中的 Loader 配置，交给对应的 Loader 去加载这个模块，最后将加载的结果放入 bundle.js（打包结果）中，从而实现整个项目的打。

对于依赖模块中无法通过 JavaScript 代码表示的资源模块，例如图片或字体文件，一般的 Loader 会将它们单独作为资源文件拷贝到输出目录中，然后将这个资源文件所对应的访问路径作为这个模块的导出成员暴露给外部。

整个打包过程中，Loader 机制起了很重要的作用，因为如果没有 Loader 的话，Webpack 就无法实现各种各样类型的资源文件加载，那 Webpack 也就只能算是一个用来合并 JS 模块代码的工具了。

至于自定义插件机制，在 04 课时中我们也详细介绍过了，它并不会影响 Webpack 的核心工作过程，只是 Webpack 为了提供一个强大的扩展能力，它为整个工作过程的每个环节都预制了一个钩子，也就是说我们可以通过插件往 Webpack 工作过程的任意环节植入一些自定义的任务，从而扩展 Webpack 打包功能以外的能力。

## 工作原理剖析

Webpack 核心工作过程中的关键环节:

- 1. Webpack CLI 启动打包流程；
> 创建配置选项，CLI参数覆盖配置文件，得到最终的配置选项options
- 2. 载入 Webpack 核心模块，创建 Compiler 对象；
> const Compiler = webpack(options), Webpack注册插件
> options Type: ```[Array, Object]```
- 3. 使用 Compiler 对象开始编译整个项目；
> 监听? watch(): run();  创建构建过程中的上下文对象Compilation
- 4. 从入口文件开始，解析模块依赖，形成依赖关系树；
- 5. 递归依赖树，将每个模块交给对应的 Loader 处理；
- 6. 合并 Loader 处理完的结果，将打包结果输出到 dist 目录。

## 一、Webpack CLI

Webpack CLI 作用： 将 CLI 参数和 Webpack 配置文件中的配置整合，得到一个完整的配置对象。

首先，Webpack CLI 会通过 yargs 模块解析 CLI 参数，所谓 CLI 参数指的就是我们在运行 webpack 命令时通过命令行传入的参数，例如 --mode=production

调用了 bin/utils/convert-argv.js 模块，将得到的命令行参数转换为 Webpack 的配置选项对象

找到配置文件过后，将配置文件中的配置和 CLI 参数中的配置合并，如果出现重复的情况，会优先使用 CLI 参数，最终得到一个完整的配置选项。

有了配置选项过后，开始载入 Webpack 核心模块，传入配置选项，创建 Compiler 对象，这个 Compiler 对象就是整个 Webpack 工作过程中最核心的对象了，负责完成整个项目的构建工作。

## 二、创建 Compiler 对象

在webpack函数中，首先校验了外部传递过来的 options 参数是否符合要求，紧接着判断了 options 的类型。

根据这个函数中的代码，我们发现 options 不仅仅可以是一个对象，还可以是一个数组。如果我们传入的是一个数组，那么 Webpack 内部创建的就是一个 MultiCompiler，也就是说 Webpack 应该支持同时开启**多路打包**，配置数组中的每一个成员就是一个独立的配置选项。而如果我们传入的是普通的对象，就会按照我们**最熟悉**的方式创建一个 Compiler 对象，进行**单线打包**。

在创建了 Compiler 对象过后，Webpack 就开始注册我们配置中的每一个插件了，因为再往后 Webpack 工作过程的生命周期就要开始了，所以必须先注册，这样才能确保插件中的每一个钩子都能被命中。

## 三、开始构建

完成 Compiler 对象的创建过后，紧接着这里的代码开始判断配置选项中是否启用了**监视模式**

- 如果是监视模式就调用 Compiler 对象的 watch 方法，以监视模式启动构建，但这不是我们主要关心的主线。
- 如果不是监视模式就调用 Compiler 对象的 run 方法，开始构建整个应用。

run方法内部就是先触发了beforeRun 和 run 两个钩子，然后最关键的是调用了当前对象的 compile 方法，真正开始编译整个项目。

compile 方法内部主要就是创建了一个 Compilation 对象，这个对象我们在 04 课时中有提到，Compilation 字面意思是“合集”，实际上，你就可以理解为一次构建过程中的上下文对象，里面包含了这次构建中全部的资源和信息。

创建完 Compilation 对象过后，紧接着触发了一个叫作 make 的钩子，进入整个构建过程最核心的 make 阶段。

## 四、make 阶段

make 阶段主体的目标就是：根据 entry 配置找到入口模块，开始依次递归出所有依赖，形成依赖关系树，然后将递归到的每个模块交给不同的 Loader 处理。

由于这个阶段的调用过程并不像之前一样，直接调用某个对象的某个方法，而是采用**事件触发机制**，让外部监听这个 make 事件的地方开始执行，所以从这里往后的代码可能找起来会费点劲儿。

这里我简单提示一下：想要知道这个事件触发后，哪些地方会开始执行，前提是得知道哪里注册了这个叫作 make 的事件。

Webpack 的插件系统是基于官方自己的 Tapable 库实现的，我们想要知道在哪里注册了某个事件，必须要知道如何注册的事件。

[关于 tapable 你需要知道这些](https://zhuanlan.zhihu.com/p/79221553)


对于 make 阶段后续的流程，这里我们概括一下：

- 1. SingleEntryPlugin 中调用了 Compilation 对象的 addEntry 方法，开始解析入口；
- 2. addEntry 方法中又调用了 _addModuleChain 方法，将入口模块添加到模块依赖列表中；
- 3. 紧接着通过 Compilation 对象的 buildModule 方法进行模块构建；
- 4. buildModule 方法中执行具体的 Loader，处理特殊资源加载；
- 5. build 完成过后，通过 acorn 库生成模块代码的 AST 语法树；
- 6. 根据语法树分析这个模块是否还有依赖的模块，如果有则继续循环 build 每个依赖；
- 7. 所有依赖解析完成，build 阶段结束；
- 8. 最后合并生成需要输出的 bundle.js 写入 dist 目录。

**因为我们阅读源代码的目的，很多时候都是为了去看某个问题在内部具体是如何实现的。**








































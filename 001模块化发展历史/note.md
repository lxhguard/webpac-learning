# 模块化发展历史

> 实现模块化的方式如下：文件划分，

## Stage 1 - 文件划分

### 1-1.实践

将每个功能及其相关状态数据各自单独放到不同的 JS 文件中，约定每个文件是一个独立的模块。

### 1-2.使用

使用A模块，则将A模块引入到页面中，一个 script 标签对应一个模块，然后直接调用模块中的成员（变量 / 函数）。

### 1-3.缺点

- 1. 污染全局作用域
- 2. 容易产生命名冲突
- 3. 模块内的成员 可 在模块外被访问和篡改
- 4. 无法管理模块与模块之间的依赖关系
- 5. 在维护的过程中也很难分辨每个成员所属的模块。

> 这是最原始的模块化实现，完全依赖于约定实现。在代码层面很容易看出123问题，



## Stage2–命名空间

### 2-1.实践

约定每个模块只暴露一个全局对象，所有模块成员都挂载到这个全局对象中。

### 2-2.使用

基于**文件划分方式**，将每个模块以一个全局对象形式实现，像是给模块内的成员添加了命名空间。

### 2-3.缺点

> 仅仅解决了第二条：命名冲突。


## Stage3–IIFE

### 2-1.实践

使用IIFE为模块提供私有空间。

### 2-2.使用

将每个模块成员都放在一个立即执行函数所形成的私有作用域中，对于需要暴露给外部的成员，通过挂到全局对象上的方式实现。

### 2-3.缺点

> 解决了前两条：全局作用域污染、命名冲突。

## Stage4-IIFE依赖参数

### 2-1.实践

在 IIFE 的基础之上，我们还可以利用 IIFE 参数作为依赖声明使用，这使得每一个模块之间的依赖关系变得更加明显。

### 2-2.使用

在 IIFE 的基础之上，我们还可以利用 IIFE 参数作为依赖声明使用，这使得每一个模块之间的依赖关系变得更加明显。

### 2-3.缺点

> 解决了前两条：全局作用域污染、命名冲突。

## 4. 四种模块化方式的总结

解决了**模块代码的组织问题**。

但忽略**模块加载**的问题：通过```<script>```标签引入的模块，意味着模块的加载并不受代码的控制，长时间会难以维护。

理想方式：在页面中引入一个 JS 入口文件，其余用到的模块可以通过**代码控制**，**按需加载**进来。

## 5. 模块化规范

### 5-1.CommonJS 规范(同步模块定义规范)

> Node.js 中所遵循的模块规范

该规范约定，一个文件就是一个模块，每个模块都有单独的作用域，通过 module.exports 导出成员，再通过 require 函数载入模块。

> CommonJS 约定的是以同步的方式加载模块，因为 Node.js 执行机制是在启动时加载模块，执行过程中只是使用模块。

> 如果要在浏览器端使用同步的加载模式，程序运行效率很低。

### 5-2. AMD 规范(异步模块定义规范)

> 这是专门为浏览器端重新设计了一个规范

> Require.js 实现了 AMD 模块化规范，同时也是一个非常强大的模块加载器。

在 AMD 规范中约定每个模块通过 define() 函数定义，这个函数默认可以接收两个参数，第一个参数是一个数组，用于声明此模块的依赖项；第二个参数是一个函数，参数与前面的依赖项一一对应，每一项分别对应依赖项模块的导出成员，这个函数的作用就是为当前模块提供一个私有空间。如果在当前模块中需要向外部导出成员，可以通过 return 的方式实现。

#### 5-2-1. 缺点

AMD 规范使用起来相对复杂，而且当项目中模块划分过于细致时，就会出现同一个页面对 js 文件的请求次数过多的情况，从而导致效率降低。

> AMD为前端模块化提供了标准，但这只是一种妥协的实现方式，并不能成为最终的解决方案。

### 5-3. CMD 规范(同步模块定义规范)

例如：淘宝的 Sea.js 实现了 CMD 模块化规范

在使用上基本和 Require.js 相同, 后来被 Require.js 兼容。

### 5-4. 模块化的标准规范

在 Node.js 环境中，我们遵循 CommonJS 规范来组织模块。(但 Node 环境也会逐渐趋向于 ES Modules 规范)
> CommonJS 属于内置模块系统，所以在 Node.js 环境中使用时不存在环境支持问题，只需要直接遵循标准使用 require 和 module 即可。
在浏览器环境中，我们遵循 ES Modules 规范。
> ES Modules 是 ECMAScript 2015（ES6）中才定义的模块系统。会存在**环境兼容**的问题。

## 6. 总结

### 6-1. 引入模块化思想带来的问题

- 1. ES Modules 模块系统存在 **环境兼容问题**
- 2. 模块化的方式划分出来的模块文件过多，前端应用运行在浏览器中，每一个文件都需要单独从服务器请求回来。零散的模块文件必然会导致浏览器的**频繁发送网络请求**，影响应用的**工作效率**。
- 3. JS模块化的发散，HTML、CSS等也需要模块化。

### 6-2. 理想化工具：解决上述问题

- 1. 具备**编译代码**的能力。能将开发阶段编写的包含新特性的代码转为能够兼容大多数环境的代码，解决**环境兼容**问题。
- 2. 将散落的模块再打包到一起。解决了**浏览器频繁请求模块文件**的问题。
> PS：在开发阶段需要模块化的文件划分，因为其能更好的组织代码；在生产阶段，这种划分就没有必要了。
- 3. 需支持不同种类的前端模块类型。所有资源都可以作为模块使用，因此具有了统一的模块化方案，所有资源文件的加载都可以通过代码控制，与业务代码统一维护，更为合理。

解决 1、2，可以采用 Gulp。
解决 1、2、3，可以采用 前端模块打包工具，如 Webpack、Parcel 和 Rollup。

> Webpack 以模块化思想为核心，帮助开发者更好的管理整个前端工程。







